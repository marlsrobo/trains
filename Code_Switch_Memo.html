<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Code Switch Memo</title>
</head>
<body>
<p>
  To: Professor Lerner and Cameron Moy
</p>
<p>
  From: Marley Robinson and Ronan Loughlin
</p>
<p>
  Date: November 6th, 2021
</p>
<p>
  RE: Codebase switch Request
</p>

<h4>
  Project Design Decisions That Illustrate Why The Gallatin Code is Preferable Over Bighorn
</h4>
<ol>
  <li>
    In the Gallatin code, the RefereeGameState handles making any modifications to the state of the
    game, as well as checking if moves are invalid. It is the job of the Referee to communicate with
    Players, eliminate any cheating players, and control flow of the game.
    In the Bighorn code there are methods in both the Referee and the RefereeGameState that modify
    the state of the game. For example, the tryCardsAction method within the Referee directly
    handles modification of the cards in the current player's hand and setting the inventory of that
    Player.
    The Gallatin code base's RefereeGameState is more clearly the source of truth for modifying and
    maintaining the state of the game.
  </li>
  <li>
    In Gallatin's code, the RefereeGameState maintains a list of PlayerData for each player left in
    the game. Each PlayerData contains a list of connections that that player occupies. The Bighorn
    RefereeGameState contains a map from connection to the PlayerID of the player that occupies it,
    or -1 if it is unoccupied. The approach used in Gallatin better contains the information about
    each player in one place, and removes for the referee and RefereeGameState to communicate using
    IDs for players.
  </li>
  <li>
    The RefereeGameState in Bighorn is initialized before setup of the game, with empty values for
    the PlayerInventory of each Player. Gallatin's RefereeGameState is not initialized until the
    game is actually about to start. It does not make sense for the game to have a state before it
    has started, which leads to the uninitialized fields in Bighorn. It also removes the need to
    update the RefereeGameState to a new, but still not valid, state after each player chooses
    destinations.
  </li>
  <li>
    The Strategy interface and abstract class in Gallatin expose only methods for the decision and
    contain a better abstraction. The Gallatin Code abstracts more of the decision making in a
    strategy to the AStrategy abstract class, and hides the extra methods as protected helpers.
  </li>
  <li>
    The Gallatin Player class only contains fields for the initial setup, and does not track and
    update its own game state. The BigHorn code stores the PlayerGameState in the Player and in the
    RefereeGameState, and updates both. The Bighorn code has to update both of these states when the
    player receives any information from the referee.
  </li>
</ol>

<h4>
  Executive Summary:
</h4>
<p>
  Gallatin's code has a clearer purpose statements for both the Referee and RefereeGameState,
  leading to better separation of responsibilities and organization of data. Gallatin's abstraction
  of the Player and Strategy classes allowed more freedom for future implementations to control
  their behavior.
</p>

</body>
</html>